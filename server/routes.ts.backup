import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { insertBookSchema, insertPageSchema, insertCommentSchema, insertNotificationSchema, insertExternalLinkSchema, insertDepartmentSchema, insertNewsSchema, insertStatSchema, insertDepartmentHierarchySchema, insertDepartmentManagerSchema, insertPageVersionSchema, insertBookVersionSchema, insertVersionAuditLogSchema } from "@shared/schema";
import multer from "multer";
import path from "path";
import fs from "fs";
import { registerHelpdeskRoutes } from "./routes/helpdesks.routes";
import { registerTicketRoutes } from "./routes/tickets.routes";
import { registerFormRoutes } from "./routes/forms.routes";
import { registerWebhookRoutes } from "./routes/webhooks.routes";
import { registerSettingsRoutes } from "./routes/settings.routes";
import { registerRolesRoutes } from "./routes/roles.routes";
import { registerAuditRoutes } from "./routes/audit.routes";
import { registerReportsRoutes } from "./routes/reports.routes";
import { registerWatercoolerRoutes } from "./routes/watercooler.routes";
import { registerAnnouncementRoutes } from "./routes/announcements.routes";
import { registerInfrastructureRoutes } from "./routes/infrastructure.routes";
import { registerAIRoutes } from "./routes/ai.routes";

const uploadsDir = path.join(process.cwd(), "uploads");
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

const upload = multer({
  storage: multer.diskStorage({
    destination: (_req, _file, cb) => cb(null, uploadsDir),
    filename: (_req, file, cb) => {
      const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
      cb(null, uniqueSuffix + path.extname(file.originalname));
    },
  }),
  limits: { fileSize: 5 * 1024 * 1024 },
  fileFilter: (_req, file, cb) => {
    const allowedTypes = ["image/png", "image/jpeg", "image/gif", "image/svg+xml", "image/webp", "image/x-icon"];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Only image files are allowed"));
    }
  },
});

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  app.get("/api/external-links", async (_req, res) => {
    const links = await storage.getExternalLinks();
    res.json(links);
  });

  app.get("/api/proxy-favicon", async (req, res) => {
    const { url } = req.query;
    if (typeof url !== 'string') return res.status(400).send("URL required");
    try {
      const domain = new URL(url).hostname;
      res.redirect(`https://icon.horse/icon/${domain}`);
    } catch (e) {
      res.status(400).send("Invalid URL");
    }
  });

  app.post("/api/external-links", async (req, res) => {
    const result = insertExternalLinkSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    const link = await storage.createExternalLink(result.data);
    res.json(link);
  });

  app.delete("/api/external-links/:id", async (req, res) => {
    await storage.deleteExternalLink(req.params.id);
    res.sendStatus(204);
  });

  app.patch("/api/external-links/reorder", async (req, res) => {
    const { ids } = req.body;
    if (!Array.isArray(ids)) return res.sendStatus(400);
    
    try {
      await Promise.all(
        ids.map((id: string, index: number) => 
          storage.updateExternalLink(id, { order: index.toString() })
        )
      );
      res.sendStatus(204);
    } catch (error) {
      console.error("Reorder error:", error);
      res.sendStatus(500);
    }
  });

  app.patch("/api/external-links/:id", async (req, res) => {
    const result = insertExternalLinkSchema.partial().safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    try {
      const link = await storage.updateExternalLink(req.params.id, result.data);
      res.json(link);
    } catch (error: any) {
      res.status(404).json({ error: error.message });
    }
  });

  // Users
  app.get("/api/users", async (_req, res) => {
    const allUsers = await storage.getUsers();
    res.json(allUsers.map(u => ({
      ...u,
      password: undefined,
    })));
  });

  // Admin endpoint to create users (doesn't auto-login)
  app.post("/api/users", async (req, res) => {
    try {
      // Require authentication for admin user creation
      if (!req.isAuthenticated()) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const { username, password, department } = req.body;
      
      if (!username || !password) {
        return res.status(400).json({ error: "Username and password are required" });
      }
      
      if (password.length < 8) {
        return res.status(400).json({ error: "Password must be at least 8 characters" });
      }

      // Check if username already exists
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(400).json({ error: "Username already exists" });
      }

      const { hashPassword } = await import("./auth");
      const hashedPassword = await hashPassword(password);

      const newUser = await storage.createUser({
        username,
        password: hashedPassword,
        department: department || "General",
      });

      // Return user without password - DON'T auto-login
      res.status(201).json({ ...newUser, password: undefined });
    } catch (error: any) {
      console.error("Create user error:", error);
      res.status(500).json({ error: error.message || "Failed to create user" });
    }
  });

  app.get("/api/users/:id", async (req, res) => {
    const user = await storage.getUser(req.params.id);
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }
    res.json({ ...user, password: undefined });
  });

  app.patch("/api/users/:id", async (req, res) => {
    const { username, department, avatar, displayName, email, phone, bio } = req.body;
    const user = await storage.getUser(req.params.id);
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }
    const updateData: Record<string, any> = {};
    if (username !== undefined) updateData.username = username;
    if (department !== undefined) updateData.department = department;
    if (avatar !== undefined) updateData.avatar = avatar;
    if (displayName !== undefined) updateData.displayName = displayName;
    if (email !== undefined) updateData.email = email;
    if (phone !== undefined) updateData.phone = phone;
    if (bio !== undefined) updateData.bio = bio;
    
    const updated = await storage.updateUser(req.params.id, updateData);
    res.json({ ...updated, password: undefined });
  });

  app.patch("/api/profile", async (req, res) => {
    if (!req.user) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    const { displayName, email, phone, bio, avatar } = req.body;
    const updateData: Record<string, any> = {};
    if (displayName !== undefined) updateData.displayName = displayName;
    if (email !== undefined) updateData.email = email;
    if (phone !== undefined) updateData.phone = phone;
    if (bio !== undefined) updateData.bio = bio;
    if (avatar !== undefined) updateData.avatar = avatar;
    
    const updated = await storage.updateUser((req.user as any).id, updateData);
    res.json({ ...updated, password: undefined });
  });

  app.post("/api/users/:id/reset-password", async (req, res) => {
    const { password } = req.body;
    if (!password || password.length < 8) {
      return res.status(400).json({ error: "Password must be at least 8 characters" });
    }
    const user = await storage.getUser(req.params.id);
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }
    const { hashPassword } = await import("./auth");
    const hashedPassword = await hashPassword(password);
    await storage.updateUser(req.params.id, { password: hashedPassword });
    res.json({ success: true });
  });

  // Departments
  app.get("/api/departments", async (_req, res) => {
    const departments = await storage.getDepartments();
    res.json(departments);
  });

  app.post("/api/departments", async (req, res) => {
    const result = insertDepartmentSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    const department = await storage.createDepartment(result.data);
    res.json(department);
  });

  app.patch("/api/departments/:id", async (req, res) => {
    const result = insertDepartmentSchema.partial().safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    try {
      const department = await storage.updateDepartment(req.params.id, result.data);
      res.json(department);
    } catch (error: any) {
      res.status(404).json({ error: error.message });
    }
  });

  app.delete("/api/departments/:id", async (req, res) => {
    const departmentId = req.params.id;
    
    // Get the department to find its name
    const departments = await storage.getDepartments();
    const department = departments.find(d => d.id === departmentId);
    
    if (!department) {
      return res.status(404).json({ error: "Department not found" });
    }
    
    // Check users by department name (users store department name, not ID)
    const users = await storage.getUsers();
    const usersInDepartment = users.filter(u => u.department === department.name);
    
    if (usersInDepartment.length > 0) {
      return res.status(400).json({ 
        error: `Cannot delete department. There are ${usersInDepartment.length} user(s) assigned to this department. Please reassign them first.`,
        userCount: usersInDepartment.length
      });
    }
    
    await storage.deleteDepartment(departmentId);
    res.sendStatus(204);
  });

  // News
  app.get("/api/news", async (_req, res) => {
    const news = await storage.getNews();
    res.json(news);
  });

  app.post("/api/news", async (req, res) => {
    const result = insertNewsSchema.safeParse(req.body);
    if (!result.success) return res.status(400).json({ error: result.error });
    const news = await storage.createNews(result.data);
    res.json(news);
  });

  // Stats
  app.get("/api/stats", async (_req, res) => {
    const stats = await storage.getStats();
    res.json(stats);
  });

  app.patch("/api/stats/:key", async (req, res) => {
    const result = insertStatSchema.partial().safeParse(req.body);
    if (!result.success) return res.status(400).json({ error: result.error });
    try {
      const stat = await storage.updateStat(req.params.key, result.data);
      res.json(stat);
    } catch (e: any) {
      res.status(404).json({ error: e.message });
    }
  });

  app.get("/api/notifications/:userId", async (req, res) => {
    const notifications = await storage.getNotifications(req.params.userId);
    res.json(notifications);
  });

  app.post("/api/notifications", async (req, res) => {
    const result = insertNotificationSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    const notification = await storage.createNotification(result.data);
    res.json(notification);
  });

  app.patch("/api/notifications/:id/read", async (req, res) => {
    try {
      const notification = await storage.markNotificationRead(req.params.id);
      res.json(notification);
    } catch (error: any) {
      res.status(404).json({ error: error.message });
    }
  });

  app.get("/api/books", async (_req, res) => {
    const books = await storage.getBooks();
    res.json(books);
  });

  app.post("/api/books", async (req, res) => {
    const result = insertBookSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    try {
      const book = await storage.createBook(result.data);
      res.json(book);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/books/:bookId", async (req, res) => {
    const book = await storage.getBook(req.params.bookId);
    if (!book) return res.status(404).send("Book not found");
    res.json(book);
  });

  app.get("/api/books/:bookId/pages", async (req, res) => {
    const pages = await storage.getPages(req.params.bookId);
    res.json(pages);
  });

  app.delete("/api/books/:bookId", async (req, res) => {
    try {
      await storage.deleteBook(req.params.bookId);
      res.json({ success: true });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.patch("/api/books/:bookId", async (req, res) => {
    try {
      const existing = await storage.getBook(req.params.bookId);
      if (!existing) return res.status(404).send("Book not found");

      const isMove = req.body.parentId !== undefined && req.body.parentId !== existing.parentId;
      const oldParentId = existing.parentId;

      const book = await storage.updateBook(req.params.bookId, req.body);

      if (isMove) {
        let fromName = 'Root';
        let toName = 'Root';
        
        if (oldParentId) {
          const oldParent = await storage.getPage(oldParentId);
          if (oldParent) fromName = oldParent.title;
        }
        
        if (req.body.parentId) {
          const newParent = await storage.getPage(req.body.parentId);
          if (newParent) toName = newParent.title;
        }
        
        await storage.createDocumentActivity({
          documentId: book.id,
          documentType: 'book',
          action: 'moved',
          userId: 'current-user-id',
          details: JSON.stringify({ from: fromName, to: toName, fromId: oldParentId, toId: req.body.parentId }),
        });
      }

      res.json(book);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/pages", async (req, res) => {
    const pages = await storage.getStandalonePages();
    res.json(pages);
  });

  app.post("/api/pages", async (req, res) => {
    const result = insertPageSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    
    // Auto-assign reviewer if status is in_review
    const pageData = result.data;
    if (pageData.status === "in_review") {
      const author = await storage.getUser(pageData.authorId);
      if (author) {
        const deptMembers = await storage.getUsersByDepartment(author.department);
        const candidates = deptMembers.filter(m => m.id !== author.id);
        if (candidates.length > 0) {
          pageData.reviewerId = candidates[Math.floor(Math.random() * candidates.length)].id;
        }
      }
    }
    
    const page = await storage.createPage(pageData);
    
    // Create notification for reviewer
    if (page.reviewerId) {
      await storage.createNotification({
        userId: page.reviewerId,
        title: "New Page for Review",
        message: `"${page.title}" has been submitted for your review.`,
        link: `/documents?pageId=${page.id}`,
        targetId: page.id,
      });
    }
    
    res.json(page);
  });

  app.get("/api/pages/:id", async (req, res) => {
    const page = await storage.getPage(req.params.id);
    if (!page) return res.status(404).send("Page not found");
    res.json(page);
  });

  app.delete("/api/pages/:id", async (req, res) => {
    try {
      await storage.deletePage(req.params.id);
      res.json({ success: true });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.patch("/api/pages/:id", async (req, res) => {
    try {
      const existing = await storage.getPage(req.params.id);
      if (!existing) return res.status(404).send("Page not found");

      // Check if this is a move operation (parentId is being changed)
      const isMove = req.body.parentId !== undefined && req.body.parentId !== existing.parentId;
      const oldParentId = existing.parentId;

      // Handle transition to review
      if (req.body.status === "in_review" && existing.status === "draft") {
        const author = await storage.getUser(existing.authorId);
        if (author) {
          const deptMembers = await storage.getUsersByDepartment(author.department);
          const candidates = deptMembers.filter(m => m.id !== author.id);
          if (candidates.length > 0) {
            req.body.reviewerId = candidates[Math.floor(Math.random() * candidates.length)].id;
          }
        }
      }

      const page = await storage.updatePage(req.params.id, req.body);

      // Log move activity
      if (isMove) {
        let fromName = 'Root';
        let toName = 'Root';
        
        if (oldParentId) {
          const oldParent = await storage.getPage(oldParentId);
          if (oldParent) fromName = oldParent.title;
        }
        
        if (req.body.parentId) {
          const newParent = await storage.getPage(req.body.parentId);
          if (newParent) toName = newParent.title;
        }
        
        await storage.createDocumentActivity({
          documentId: page.id,
          documentType: page.type,
          action: 'moved',
          userId: 'current-user-id',
          details: JSON.stringify({ from: fromName, to: toName, fromId: oldParentId, toId: req.body.parentId }),
        });
      }

      // Create notification for status changes
      if (req.body.status === "in_review" && page.reviewerId) {
        await storage.createNotification({
          userId: page.reviewerId,
          title: "New Page for Review",
          message: `"${page.title}" has been submitted for your review.`,
          link: `/documents?pageId=${page.id}`,
          targetId: page.id,
        });
      } else if (req.body.status === "published") {
        // Resolve review notification if it exists
        const reviewNotif = await (storage as any).getActiveReviewNotification(page.reviewerId, page.id);
        if (reviewNotif) {
          await storage.markNotificationRead(reviewNotif.id);
        }

        await storage.createNotification({
          userId: page.authorId,
          title: "Page Published",
          message: `Your page "${page.title}" has been published.`,
          link: `/documents?pageId=${page.id}`,
          targetId: page.id,
        });
      }

      res.json(page);
    } catch (error: any) {
      res.status(404).json({ error: error.message });
    }
  });

  app.get("/api/pages/:id/comments", async (req, res) => {
    const comments = await storage.getComments(req.params.id);
    res.json(comments);
  });

  app.post("/api/pages/:id/comments", async (req, res) => {
    const result = insertCommentSchema.safeParse({ ...req.body, pageId: req.params.id });
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    const comment = await storage.createComment(result.data);

    // Create notification for page author
    const page = await storage.getPage(result.data.pageId);
    if (page && page.authorId !== result.data.userId) {
      await storage.createNotification({
        userId: page.authorId,
        title: "New Comment",
        message: `Someone commented on your page "${page.title}".`,
      });
    }

    res.json(comment);
  });

  app.get("/api/pages/search", async (req, res) => {
    const { bookId, title } = req.query;
    if (typeof bookId !== 'string' || typeof title !== 'string') {
      return res.status(400).send("Invalid query params");
    }
    const page = await storage.getPageByTitle(bookId, title);
    res.json(page || null);
  });

  // ============================================
  // VERSION HISTORY ROUTES
  // ============================================

  // Page versions
  app.get("/api/pages/:id/versions", async (req, res) => {
    const versions = await storage.getPageVersions(req.params.id);
    res.json(versions);
  });

  app.get("/api/pages/:id/versions/:versionNumber", async (req, res) => {
    const version = await storage.getPageVersion(req.params.id, parseInt(req.params.versionNumber));
    if (!version) return res.status(404).json({ error: "Version not found" });
    res.json(version);
  });

  app.post("/api/pages/:id/versions", async (req, res) => {
    try {
      const page = await storage.getPage(req.params.id);
      if (!page) return res.status(404).json({ error: "Page not found" });
      
      const latestVersion = await storage.getLatestPageVersionNumber(req.params.id);
      const newVersionNumber = latestVersion + 1;
      
      const versionData = {
        pageId: req.params.id,
        versionNumber: newVersionNumber,
        title: page.title,
        content: page.content,
        status: page.status,
        authorId: req.body.authorId || page.authorId,
        changeDescription: req.body.changeDescription || null,
      };
      
      const result = insertPageVersionSchema.safeParse(versionData);
      if (!result.success) return res.status(400).json({ error: result.error });
      
      const version = await storage.createPageVersion(result.data);
      
      // Log the version creation
      await storage.createVersionAuditLog({
        documentId: req.params.id,
        documentType: "page",
        actionType: "created",
        toVersion: newVersionNumber,
        userId: req.body.authorId || page.authorId,
        userName: req.body.userName,
        details: JSON.stringify({ title: page.title, changeDescription: req.body.changeDescription }),
      });
      
      res.json(version);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/pages/:id/revert/:versionNumber", async (req, res) => {
    try {
      const targetVersion = await storage.getPageVersion(req.params.id, parseInt(req.params.versionNumber));
      if (!targetVersion) return res.status(404).json({ error: "Version not found" });
      
      const currentPage = await storage.getPage(req.params.id);
      if (!currentPage) return res.status(404).json({ error: "Page not found" });
      
      // Save current state as a new version before reverting
      const latestVersion = await storage.getLatestPageVersionNumber(req.params.id);
      await storage.createPageVersion({
        pageId: req.params.id,
        versionNumber: latestVersion + 1,
        title: currentPage.title,
        content: currentPage.content,
        status: currentPage.status,
        authorId: currentPage.authorId,
        changeDescription: `Auto-saved before reverting to version ${req.params.versionNumber}`,
      });
      
      // Revert the page to the target version
      const revertedPage = await storage.updatePage(req.params.id, {
        title: targetVersion.title,
        content: targetVersion.content,
      });
      
      // Log the reversion
      await storage.createVersionAuditLog({
        documentId: req.params.id,
        documentType: "page",
        actionType: "reverted",
        fromVersion: latestVersion + 1,
        toVersion: parseInt(req.params.versionNumber),
        userId: req.body.userId || currentPage.authorId,
        userName: req.body.userName,
        details: JSON.stringify({ revertedToTitle: targetVersion.title }),
      });
      
      // Create activity feed notification
      await storage.createDocumentActivity({
        documentId: req.params.id,
        documentType: "page",
        action: "reverted",
        userId: req.body.userId || currentPage.authorId,
        details: JSON.stringify({
          fromVersion: latestVersion + 1,
          toVersion: parseInt(req.params.versionNumber),
          userName: req.body.userName,
        }),
      });
      
      // Notify page author if different from reverter
      if (req.body.userId && req.body.userId !== currentPage.authorId) {
        await storage.createNotification({
          userId: currentPage.authorId,
          title: "Page Reverted",
          message: `"${revertedPage.title}" was reverted to version ${req.params.versionNumber} by ${req.body.userName || 'a user'}.`,
          link: `/documents?pageId=${req.params.id}`,
          targetId: req.params.id,
        });
      }
      
      res.json(revertedPage);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.delete("/api/pages/:id/versions/:versionId", async (req, res) => {
    try {
      await storage.deletePageVersion(req.params.versionId);
      
      await storage.createVersionAuditLog({
        documentId: req.params.id,
        documentType: "page",
        actionType: "deleted",
        userId: req.body.userId || "system",
        details: JSON.stringify({ deletedVersionId: req.params.versionId }),
      });
      
      res.json({ success: true });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/pages/:id/versions/:versionId/archive", async (req, res) => {
    try {
      const version = await storage.archivePageVersion(req.params.versionId);
      
      await storage.createVersionAuditLog({
        documentId: req.params.id,
        documentType: "page",
        actionType: "archived",
        toVersion: version.versionNumber,
        userId: req.body.userId || "system",
      });
      
      res.json(version);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/pages/:id/versions/:versionId/restore", async (req, res) => {
    try {
      const version = await storage.restorePageVersion(req.params.versionId);
      
      await storage.createVersionAuditLog({
        documentId: req.params.id,
        documentType: "page",
        actionType: "restored",
        toVersion: version.versionNumber,
        userId: req.body.userId || "system",
      });
      
      res.json(version);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Book versions
  app.get("/api/books/:id/versions", async (req, res) => {
    const versions = await storage.getBookVersions(req.params.id);
    res.json(versions);
  });

  app.get("/api/books/:id/versions/:versionNumber", async (req, res) => {
    const version = await storage.getBookVersion(req.params.id, parseInt(req.params.versionNumber));
    if (!version) return res.status(404).json({ error: "Version not found" });
    res.json(version);
  });

  app.post("/api/books/:id/versions", async (req, res) => {
    try {
      const book = await storage.getBook(req.params.id);
      if (!book) return res.status(404).json({ error: "Book not found" });
      
      const latestVersion = await storage.getLatestBookVersionNumber(req.params.id);
      const newVersionNumber = latestVersion + 1;
      
      const versionData = {
        bookId: req.params.id,
        versionNumber: newVersionNumber,
        title: book.title,
        description: book.description,
        authorId: req.body.authorId || book.authorId,
        changeDescription: req.body.changeDescription || null,
      };
      
      const result = insertBookVersionSchema.safeParse(versionData);
      if (!result.success) return res.status(400).json({ error: result.error });
      
      const version = await storage.createBookVersion(result.data);
      
      await storage.createVersionAuditLog({
        documentId: req.params.id,
        documentType: "book",
        actionType: "created",
        toVersion: newVersionNumber,
        userId: req.body.authorId || book.authorId,
        userName: req.body.userName,
        details: JSON.stringify({ title: book.title, changeDescription: req.body.changeDescription }),
      });
      
      res.json(version);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/books/:id/revert/:versionNumber", async (req, res) => {
    try {
      const targetVersion = await storage.getBookVersion(req.params.id, parseInt(req.params.versionNumber));
      if (!targetVersion) return res.status(404).json({ error: "Version not found" });
      
      const currentBook = await storage.getBook(req.params.id);
      if (!currentBook) return res.status(404).json({ error: "Book not found" });
      
      const latestVersion = await storage.getLatestBookVersionNumber(req.params.id);
      await storage.createBookVersion({
        bookId: req.params.id,
        versionNumber: latestVersion + 1,
        title: currentBook.title,
        description: currentBook.description,
        authorId: currentBook.authorId,
        changeDescription: `Auto-saved before reverting to version ${req.params.versionNumber}`,
      });
      
      const revertedBook = await storage.updateBook(req.params.id, {
        title: targetVersion.title,
        description: targetVersion.description,
      });
      
      await storage.createVersionAuditLog({
        documentId: req.params.id,
        documentType: "book",
        actionType: "reverted",
        fromVersion: latestVersion + 1,
        toVersion: parseInt(req.params.versionNumber),
        userId: req.body.userId || currentBook.authorId,
        userName: req.body.userName,
      });
      
      await storage.createDocumentActivity({
        documentId: req.params.id,
        documentType: "book",
        action: "reverted",
        userId: req.body.userId || currentBook.authorId,
        details: JSON.stringify({
          fromVersion: latestVersion + 1,
          toVersion: parseInt(req.params.versionNumber),
          userName: req.body.userName,
        }),
      });
      
      res.json(revertedBook);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Version audit logs
  app.get("/api/version-audit-logs", async (req, res) => {
    const limit = parseInt(req.query.limit as string) || 100;
    const offset = parseInt(req.query.offset as string) || 0;
    const logs = await storage.getAllVersionAuditLogs(limit, offset);
    res.json(logs);
  });

  app.get("/api/version-audit-logs/:documentType/:documentId", async (req, res) => {
    const logs = await storage.getVersionAuditLogs(req.params.documentId, req.params.documentType);
    res.json(logs);
  });

  // Version search
  app.get("/api/versions/search", async (req, res) => {
    const query = req.query.q;
    if (typeof query !== "string") return res.status(400).json({ error: "Query required" });
    
    const results = await storage.searchVersions(query);
    
    // Format results with legacy version indicators
    const formattedPageVersions = results.pageVersions.map(v => ({
      ...v,
      displayLabel: v.isArchived === "true" 
        ? `[Archived – Last Updated: ${new Date(v.createdAt).toLocaleDateString()}]`
        : `[Legacy Version – v${v.versionNumber}]`,
    }));
    
    const formattedBookVersions = results.bookVersions.map(v => ({
      ...v,
      displayLabel: v.isArchived === "true"
        ? `[Archived – Last Updated: ${new Date(v.createdAt).toLocaleDateString()}]`
        : `[Legacy Version – v${v.versionNumber}]`,
    }));
    
    res.json({ pageVersions: formattedPageVersions, bookVersions: formattedBookVersions });
  });

  // Compare versions
  app.get("/api/pages/:id/compare/:v1/:v2", async (req, res) => {
    try {
      const version1 = await storage.getPageVersion(req.params.id, parseInt(req.params.v1));
      const version2 = await storage.getPageVersion(req.params.id, parseInt(req.params.v2));
      
      if (!version1 || !version2) {
        return res.status(404).json({ error: "One or both versions not found" });
      }
      
      res.json({
        version1,
        version2,
        comparison: {
          titleChanged: version1.title !== version2.title,
          contentChanged: version1.content !== version2.content,
          statusChanged: version1.status !== version2.status,
        },
      });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/search", async (req, res) => {
    const query = req.query.q;
    const includeVersions = req.query.includeVersions === "true";
    if (typeof query !== "string") return res.status(400).send("Query required");
    
    const books = await storage.getBooks();
    const pages = await storage.getStandalonePages();
    const departments = await storage.getDepartments();
    
    const results: Array<{
      type: string;
      id: string;
      title: string;
      link: string;
      displayLabel?: string;
      isLegacy?: boolean;
      versionNumber?: number;
    }> = [
      ...books.filter(b => b.title.toLowerCase().includes(query.toLowerCase()))
        .map(b => ({ type: 'book', id: b.id, title: b.title, link: `/documents/book/${b.id}` })),
      ...pages.filter(p => p.title.toLowerCase().includes(query.toLowerCase()))
        .map(p => ({ type: 'page', id: p.id, title: p.title, link: `/documents/edit/${p.id}` })),
      ...departments.filter(d => d.name.toLowerCase().includes(query.toLowerCase()))
        .map(d => ({ type: 'department', id: d.id, title: d.name, link: `/system-settings` }))
    ];
    
    // Include legacy versions in search if requested or by default
    if (includeVersions !== false) {
      try {
        const versionResults = await storage.searchVersions(query);
        
        // Add page versions with legacy indicators
        versionResults.pageVersions.forEach(v => {
          const isArchived = v.isArchived === "true";
          const displayLabel = isArchived 
            ? `[Archived – Last Updated: ${new Date(v.createdAt).toLocaleDateString('en-GB')}]`
            : `[Legacy Version – v${v.versionNumber}]`;
          
          results.push({
            type: 'page_version',
            id: v.id,
            title: v.title,
            link: `/documents/edit/${v.pageId}?version=${v.versionNumber}`,
            displayLabel,
            isLegacy: true,
            versionNumber: v.versionNumber,
          });
        });
        
        // Add book versions with legacy indicators
        versionResults.bookVersions.forEach(v => {
          const isArchived = v.isArchived === "true";
          const displayLabel = isArchived 
            ? `[Archived – Last Updated: ${new Date(v.createdAt).toLocaleDateString('en-GB')}]`
            : `[Legacy Version – v${v.versionNumber}]`;
          
          results.push({
            type: 'book_version',
            id: v.id,
            title: v.title,
            link: `/documents/book/${v.bookId}?version=${v.versionNumber}`,
            displayLabel,
            isLegacy: true,
            versionNumber: v.versionNumber,
          });
        });
      } catch (e) {
        // Version search failed, continue with regular results
        console.error("Version search error:", e);
      }
    }
    
    res.json(results);
  });

  // Watercooler
  app.get("/api/watercooler", async (_req, res) => {
    const messages = await storage.getWatercoolerMessages();
    res.json(messages);
  });

  app.post("/api/watercooler", async (req, res) => {
    const result = insertCommentSchema.safeParse({ ...req.body, pageId: "watercooler" });
    if (!result.success) return res.status(400).json({ error: result.error });
    const message = await storage.createWatercoolerMessage(result.data);
    res.json(message);
  });

  // Serve uploaded files
  app.use("/uploads", (req, res, next) => {
    const filePath = path.join(uploadsDir, req.path.replace(/^\//, ""));
    if (fs.existsSync(filePath)) {
      res.sendFile(filePath);
    } else {
      res.status(404).send("File not found");
    }
  });

  // File upload endpoint
  app.post("/api/upload", upload.single("file"), (req, res) => {
    if (!req.file) {
      return res.status(400).json({ error: "No file uploaded" });
    }
    const fileUrl = `/uploads/${req.file.filename}`;
    res.json({ url: fileUrl, filename: req.file.filename });
  });

  // ============== SETTINGS ROUTES ==============
  // Routes moved to separate modules for better organization
  registerSettingsRoutes(app);

  // ============== HELPDESK ROUTES ==============
  // Routes moved to separate modules for better organization
  registerHelpdeskRoutes(app);

  // Department Hierarchy
  app.get("/api/department-hierarchy", async (_req, res) => {
    const hierarchy = await storage.getDepartmentHierarchy();
    res.json(hierarchy);
  });

  app.get("/api/department-hierarchy/children/:parentId", async (req, res) => {
    const children = await storage.getChildDepartments(req.params.parentId);
    res.json(children);
  });

  app.post("/api/department-hierarchy", async (req, res) => {
    const result = insertDepartmentHierarchySchema.safeParse(req.body);
    if (!result.success) return res.status(400).json({ error: result.error });
    const hierarchy = await storage.createDepartmentHierarchy(result.data);
    res.json(hierarchy);
  });

  app.delete("/api/department-hierarchy/:id", async (req, res) => {
    await storage.deleteDepartmentHierarchy(req.params.id);
    res.sendStatus(204);
  });

  // Department Managers
  app.get("/api/departments/:departmentId/managers", async (req, res) => {
    const managers = await storage.getDepartmentManagers(req.params.departmentId);
    res.json(managers);
  });

  app.post("/api/departments/:departmentId/managers", async (req, res) => {
    const result = insertDepartmentManagerSchema.safeParse({ ...req.body, departmentId: req.params.departmentId });
    if (!result.success) return res.status(400).json({ error: result.error });
    const manager = await storage.createDepartmentManager(result.data);
    res.json(manager);
  });

  app.patch("/api/department-managers/:id", async (req, res) => {
    const result = insertDepartmentManagerSchema.partial().safeParse(req.body);
    if (!result.success) return res.status(400).json({ error: result.error });
    try {
      const manager = await storage.updateDepartmentManager(req.params.id, result.data);
      res.json(manager);
    } catch (error: any) {
      res.status(404).json({ error: error.message });
    }
  });

  app.delete("/api/department-managers/:id", async (req, res) => {
    await storage.deleteDepartmentManager(req.params.id);
    res.sendStatus(204);
  });

  // ============== TICKET ROUTES ==============
  // Routes moved to separate modules for better organization
  registerTicketRoutes(app);

  // ============== WEBHOOK ROUTES ==============
  // Routes moved to separate modules for better organization
  registerWebhookRoutes(app);

  // ============== FORM ROUTES ==============
  // Routes moved to separate modules for better organization
  registerFormRoutes(app);

  // ============== RBAC ROUTES ==============
  // Routes moved to separate modules for better organization
  registerRolesRoutes(app);

  // ============== AUDIT LOG ROUTES ==============
  // Routes moved to separate modules for better organization
  registerAuditRoutes(app);

  // ============== REPORTS ROUTES ==============
  // Routes moved to separate modules for better organization
  registerReportsRoutes(app);

  // ============== WATERCOOLER ROUTES ==============
  // Routes moved to separate modules for better organization
  registerWatercoolerRoutes(app);

  // ============== ANNOUNCEMENT ROUTES ==============
  // Routes moved to separate modules for better organization
  registerAnnouncementRoutes(app);

  // ============== INFRASTRUCTURE ROUTES ==============
  // Routes moved to separate modules for better organization
  registerInfrastructureRoutes(app);

  // ============== AI ROUTES ==============
  // Routes moved to separate modules for better organization
  registerAIRoutes(app);


  // Users by department (for Online Team Members)
  app.get("/api/users/department/:department", async (req, res) => {
    const users = await storage.getUsersByDepartment(req.params.department);
    res.json(users.map(u => ({ id: u.id, username: u.username, department: u.department, avatar: u.avatar })));
  });

  // Search tracking and trending topics
  app.post("/api/search-history", async (req, res) => {
    if (!req.isAuthenticated()) return res.status(401).send("Unauthorized");
    try {
      const history = await storage.createSearchHistory({
        ...req.body,
        userId: req.user!.id,
        departmentId: req.user!.department,
      });
      res.status(201).json(history);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/trending-topics", async (req, res) => {
    const departmentId = req.query.departmentId as string | undefined;
    const limit = req.query.limit ? parseInt(req.query.limit as string) : 10;
    const topics = await storage.getTrendingTopics(departmentId, limit);
    res.json(topics);
  });



  return httpServer;
}
